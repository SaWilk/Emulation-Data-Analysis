%% Parallelize Tracking and EEG Data

% creation date: 02.06.2022
% Author: Saskia Wilken

% this script
% -reads in tracking data,
% - upsamples it,
% - calculates tracking error,
% - loads in preprocessed continuous EEG files,
% - imputes peak and end trial triggers in the event structure field,
% - removes practice trial triggers
% - adds a field with the trial number, the task, the trial latency and the
% trial latency in ms to the event structure.
% - rejects trials where participants did not track properly.
% - replaces the constant traj_trigger with the ones generated by the
% function
% - saves eeglab .sets that contain the new event field and a .mat file
% that contains that contains the tracking data.


%% Empty

format compact
format long G
clear
clc

%% if run from dresden, add path of eeglab
addpath('R:\AG-Beste-Orga\Skripts\Toolbox\eeglab2021.0');

%% Set Paths

% file location
file_path = matlab.desktop.editor.getActiveFilename;
file_path = fileparts(file_path);
addpath(file_path)
% tracking data
parent_path = strsplit(file_path, filesep);
parent_path(end) = [];
grandparent_path = parent_path;
parent_path = strjoin(parent_path, filesep);
grandparent_path(end) = [];
grandparent_path = strjoin(grandparent_path, filesep);
% get root path to data folder
track_data_path = strjoin([grandparent_path, "Emulation-Data-Input", "00_npz_files"], filesep);
subj_paths = genpath(track_data_path); % generate subfolder paths
subj_paths = strsplit(subj_paths, ";"); % split the string vector at ;
subj_paths(1) = []; % remove top level entry
subj_paths(end) = []; % remove final entry

% eeg data
eeg_data_path = strjoin([grandparent_path, "Emulation-Data-Output", "02_IClabel"], filesep); % get root path to data folder
% contains raw and preprocessed folders

% get subject ids from folder names
[~, tmp] = fileparts(subj_paths);
subj_ids = split(tmp, '_');
subj_ids = subj_ids(:, :, 1);
subj_ids = unique(subj_ids);
num_subj = length(subj_ids); % get num of subfolders

% initialize data structure
track_data = struct();
clear tmp

% add functions in parent dir
addpath([char(parent_path) filesep 'functions']);


%% Load Tracking data

warning("off","all");
paths{1} = subj_paths(endsWith(subj_paths, "_A"));
paths{2} = subj_paths(endsWith(subj_paths, "_B"));

% what is contained in the different columns
col_names = {'traj_x', 'traj_y', 'purs_x', 'purs_y', 'error', 'error_abs'};
task_names = {"task_a", "task_b"};
for task = 1:2
    for p = 1:length(paths{task})
        if ~isempty(paths{task}{p}) % check if there is data
            cd(paths{task}{p});
            file_names_curr_subj = {dir('*traj_purs*.csv').name};
            track_data(p).("subject") = extractBefore([file_names_curr_subj{1}],'_');
            track_data(p).("group") = 'control'; % TODO: Adjust if there is ever another group
            track_data(p).("path").(task_names{task}) = paths{task}{p};
            for t = 1:length(file_names_curr_subj)
                tmp_mat = table2array(readtable(file_names_curr_subj{t}));
                for c = 1:size(col_names,2)
                    track_data(p).("trials").(task_names{task})(t).(col_names{c}) = tmp_mat(:,c);
                end
                clear tmp_mat
            end
        else fprintf('%s contains no data', a_paths{p});
        end
    end
end
warning("on","all");


%% Upsample Tracking Data to Match EEG Data SR

% decided on spline interpolation because of this convincing comparison:
% https://de.mathworks.com/help/matlab/ref/pchip.html
% spline works best to display oscillatory movements.

FR = 60;
SR = 250;

% keep only subject ids that are also a field in track_data.

for s = 1:length(track_data)

    % this is such smart code...
    % it will loop through subj ids but give an index where the
    % elements of subj ids are in track_data
    tmp_idx(s) = find(cellfun(@isequal, subj_ids , ...
        repmat({track_data(s).subject}, size(subj_ids))));

end
subj_ids = subj_ids(tmp_idx);
clear tmp_idx

name_cols = {'traj_x', 'traj_y', 'purs_y'};

% upsample tracking data and transfer into time domain
for s = 1:length(subj_ids)
    for task = 1:2
        for t = 1:size(track_data(s).trials.(task_names{task}), 2)

            tmp_traj_y = track_data(s).trials.(task_names{task})(t).traj_y;
            % create time vec
            time_vec = linspace(0, length(tmp_traj_y)/FR*1000, round(length(tmp_traj_y))).';
            % intepolated time vec
            inter_time_vec = linspace(time_vec(1), time_vec(end), round(length(time_vec)/FR*SR));
            % interpolate using spline interpolation
            inter_traj_y = spline(time_vec, tmp_traj_y, inter_time_vec);

            % proof that it works well:
            %         figure
            %         plot(no_points, inter_traj_y, 'ob')
            %         hold on
            %         plot(time_vec, tmp_traj_y, '.r')
            %         hold off
            % same for pursuit
            tmp_purs_y = track_data(s).trials.(task_names{task})(t).purs_y;
            inter_purs_y = spline(time_vec, tmp_purs_y, inter_time_vec);
            % note that x axis points are milliseconds now.

            % proof that it works well:
            %         figure
            %         plot(tmp_purs_x, tmp_purs_y, 'ob')
            %         hold on
            %         plot(no_points, inter_purs_y, '.r')
            %         hold off

            % for now, I am just deleting the error columns
            % TODO: adjust or re-calculate error in Matlab
            tmp_mat = [inter_time_vec; inter_traj_y; inter_purs_y].';

            for c = 1:size(tmp_mat, 2)
                track_data(s).("upsamp_data").(task_names{task})(t).(name_cols{c}) = tmp_mat(:,c);
            end
        end
        clear tmp_traj_y tmp_purs_y tmp_mat
    end
end


%% Calculate difference between pursuit and trajectory (error)

for s = 1:length(subj_ids)
    for task = 1:2
        for t = 1:size(track_data(s).trials.(task_names{task}), 2)
            cur_traj = track_data(s).upsamp_data.(task_names{task})(t).traj_y;
            cur_purs = track_data(s).upsamp_data.(task_names{task})(t).purs_y;
            cur_err = abs(cur_traj - cur_purs);
            cur_mean_err = mean(cur_err);
            track_data(s).upsamp_data.(task_names{task})(t).("error") = cur_err;
            track_data(s).upsamp_data.(task_names{task})(t).("mean_error") = cur_mean_err;
        end
    end
end

clear cur_traj cur_purs cur_err


%% Load EEG data

% now we need eeglab
eeglab;
close all
cd(eeg_data_path);
% get all set files in the folder
files2read = {dir('*.set').name};
% only get files for a for now
% there is only merged a and b available, so this line is no longer needed.
% Was for separating a and b task files.
% files2read_a = files2read(~cellfun(@isempty, regexp(files2read,'_A_')));

EEG = pop_loadset('filename', files2read);
[ALLEEG, EEG, CURRENTSET] = eeg_store( ALLEEG, EEG, 0 );
eeg_struct = ALLEEG;


%% Put Tracking and EEG Data in the same structure / or actually, just
% remove subjects that have no corresponding eeg data.

% all_data_struct = eeg_struct;

% remove all subjects that have no correcponding tracking data

for s = 1:length(eeg_struct)

    % this is such smart code...
    % it will loop through all data struct but give an index where the
    % elements of all_data_struct are in track_data
    tmp_idx(s) = find(cellfun(@isequal, {track_data.subject}, ...
        repmat({eeg_struct(s).subject}, size({track_data.subject}))));

end
% keep only subjects with eeg and tracking data
backup_data = track_data;
track_data = track_data(tmp_idx);
subj_ids = subj_ids(tmp_idx);


% Deprecated: Put tracking and eeg data in same strucure
% TODO: write them directly in a 3D Matrix instead of in fields inside a
% structure
% field_names = fieldnames(copy_data);
% % nope, it does not seem to be possible to concatenate structures
% % without a loop
% for s = 1:size(copy_data,2)
%     if strcmp(copy_data(s).subject, all_data_struct(s).subject)
%         for f = 1:length(field_names)
%             % put tracking data in all data struct
%             all_data_struct(s).(field_names{f}) = copy_data(s).(field_names{f});
%         end
%     else
%         disp(strcat(all_data_struct(s).subject, " has no matching tracking data"));
%     end
% end


%% Insert Trial Start and End Events, Remove Practice Trials, Add Trial Number and Latency Fields
% (Necessary cause Peaks are only given in Trial Latency)

%   "instruction":  10,
%     "exp_start":    11,
%     "fix":          12,
%     "trial_start_L":13,
%     "trial_start_R":14,
%     "trial_end":    15, # superfluous with fix trigger (except for break)
%     "pause_start":  16,
%     "pause_end":    17,
%     "exp_end":      18,
%     "button":       19,
%     "occlusion":    20,
%     "reappear":     21,
%     "fourth_trial": 22,
%     "start_constant": 23,
%     "end_constant": 24,
%     "fourth trial": 25,
%     "start_startvec": 26,
%     "end_startvec": 27,
%     "C_too_early":  28,
%     "C_just_right": 29,
%     "C_too_late":   30,
% custom: "S 15": End Trial
% custom: "S 40": Peak max
% custom: "S 50": Peak min

NOLATENCIES = {'none'};

for s = 1:size(eeg_struct,2)

    % copy urevent field to other field
    eeg_struct(s).track_event = eeg_struct(s).urevent;
    % copy event field to convenient format
    event = eeg_struct(s).track_event;
    % anomaly in data: subject ZV583 has two fixation cross triggers really
    % close to one another without a trial in between. Will delete them
    % manually.
    if strcmp(eeg_struct(s).subject, 'ZV583')
        % identify trial number.
        % [val, idx] = min(diff(find(strcmp({event.type}, 'S 12'))))
        event(688:689)= [];
    end

    event_cat = categorical({event.type});
    categories(event_cat);
    % if you should ever feel the need to count cats, there you go:
    countcats(event_cat); % this gives you how many triggers of each type there are.

    % is this task c?
    if any(strcmp({event.type}, repmat("S 30",size({event.type},1), size({event.type},2) ))) | ...
            any(strcmp({event.type}, repmat("S 28",size({event.type},1), size({event.type},2) )))
        warning(strcat(['Caution! Subject', eeg_struct(s).subject, 'seems to be a task C trigger file. Skipping']));
        continue
        % if it is not, is this task b?
        %     elseif any(strcmp({event.type}, repmat("S 20",size({event.type},1), size({event.type},2) ))) | ...
        %            any(strcmp({event.type}, repmat("S 21",size({event.type},1), size({event.type},2) )))
        %         warning(strcat(['Caution! Subject', eeg_struct(s).subject, ' seems to be a task B trigger file. Skipping']));
        %         continue
    end

    % delete all triggers before S11
    start_pract = find(strcmp({event.code}, "New Segment"))+1;
    end_pract = find(strcmp({event.type}, "S 11"))-1;
    event([start_pract(1):end_pract(1), start_pract(2):end_pract(2)]) = [];

    % insert end trial triggers

    last_trigger = "none";

    % loop through elements of event_types.
    i = 0;
    while i < length({event.type})
        i = i + 1;
        start_exp = find(strcmp({event.code}, "New Segment"));

        % if an event type is either 16 or 12...
        if (strcmp(event(i).type, "S 16") | strcmp(event(i).type, "S 12"))
            % make sure the first entry after S 11 is skipped (since the first fix cross
            % is not a trial end) via checking whether i is shortly after S
            % 11
            if any(start_exp(1):start_exp(1)+4 == i) | any(start_exp(2):start_exp(2)+4 == i)
                continue
            end

            % and exclude the first 12 after a pause, cause it's also not a
            % trial end.
            if strcmp(last_trigger, "S 16")
                last_trigger = "none";
                continue
            end
            %             disp(strcat("is true for ", num2str(i)))
            %             disp(strcat("following event", event(i+1).type))
            % save current trigger for next loop iteration
            last_trigger = event(i).type;
            % copy the row in question
            event = [event(1:i-1), event(i), event(i:end)];
            % replace the copied rows' type with S 15
            event(i).type = 'S 15';
            event(i).code = 'inserted';
            % increment i additionally because we just inserted a trigger
            i = i + 1;
        end

    end
    % add an end trial trigger to very end of trigger list
    event = [event, event(end)];
    event(end).type = 'S 15';
    event(end).code = 'inserted';
    % and before S 11
    event = [event(1:start_exp(2)-1), event(start_exp(2)-1), event(start_exp(2):end)];
    event(start_exp(2)-1).type = 'S 15';
    event(start_exp(2)-1).code = 'inserted';
    % copy the new event_types struct into track event
    eeg_struct(s).track_event = event;

    % start trial indices
    % get the indices of the "S 27" in event.type
    trial_start_ind = strcmp({event.type}, "S 27");
    trial_starts = find(trial_start_ind);

    % end trial indices
    % get the indices of the "S 15" in event.type
    trial_end_ind = strcmp({event.type}, "S 15");
    trial_ends = find(trial_end_ind);

    latencies = [event.latency];

    % add new field: trial_latency
    tmp = num2cell(latencies);
    % todo here: latencies set to 0 at beginnings of trials so I can use
    % the findpeaks function to get the right timing
    % probably requires a loop.

    % this syntax is confusing as hell. left hand side of the assignment needs
    % to be a vector, right hand side single outputs and matlab is happy...
    [eeg_struct(s).track_event.trial_latency] = tmp{:};

    % update event
    event = eeg_struct(s).track_event;
    % initialize trial number field
    tmp = num2cell(repmat(9999, size(eeg_struct(s).track_event)));
    [event.("trial_number")] = tmp{:};

    if length(trial_starts) == length(trial_ends)
        % loop through trial start indices
        for idx = 1:length(trial_starts)
            % set per trial latencies of events in trial
            trial_event_latencies = [event(trial_starts(idx):trial_ends(idx)).trial_latency] - ...
                event(trial_starts(idx)).trial_latency;
            trial_event_latencies_cell =  num2cell(trial_event_latencies);
            [event(trial_starts(idx):trial_ends(idx)).trial_latency] = trial_event_latencies_cell{:};
            % add field: trial number
            if idx <= 72
                trial_num = idx;
            elseif 72 < idx <= 72*2
                trial_num = idx - 72;
            else
                trial_num = idx - 72*2;
            end
            trial_idx = num2cell(repmat(trial_num, size(trial_event_latencies_cell)));
            [event(trial_starts(idx):trial_ends(idx)).("trial_number")] = trial_idx{:};
            % add field: trial latency ms
            trial_event_latencies_ms = num2cell(trial_event_latencies/250*1000);
            [event(trial_starts(idx):trial_ends(idx)).("trial_latency_ms")] = trial_event_latencies_ms{:};
        end
    else
        warning(strcat(['Subject ', eeg_struct(s).subject, ...
            ' has an unequal number of trial start and trial end triggers!', ...
            ' No trial latencies will be computed. ']));
        NOLATENCIES = eeg_struct(s).subject;
    end

    eeg_struct(s).track_event = event;

end


% Notes: 91L3HA is excluded because recording started too late.
% WM87B is excluded cause there is no behavioral data.


%% Find Peaks of Tracking Data and put them in Events

% TODO: change it to be two different peak markers, one for max, one for
% min
% "S 40": Peak max
% "S 50": Peak min


PROMINENCE_TRHESH = 0.01;

for s = 1:size(eeg_struct,2)

    event = eeg_struct(s).track_event;
    if ~strcmp(NOLATENCIES, eeg_struct(s).subject)
        for task = 1:2
            % get eeg triggers of current task
            exp_ind = [find(strcmp({event.code}, "New Segment"))-1, length({event.type})];
            exp_ind(1) = 1;
            % add field to events: task
            task_labels = cellstr(repmat(task_names{task}, [1, length(exp_ind(task):exp_ind(task+1))]));
            [event(exp_ind(task):exp_ind(task+1)).("task")] = task_labels{:};
            event_cur_task = event(find(strcmp({event.task}, task_names{task})));

            for t = 1:size(track_data(s).upsamp_data.(task_names{task}),2)

                current_trial_traj = track_data(s).upsamp_data.(task_names{task})(t).traj_y;

                % get peak indices within trial trajectory data
                [~, index_max_traj, ~, prom_max_traj] = findpeaks(current_trial_traj);
                [~, index_min_traj, ~, prom_min_traj] = findpeaks(-current_trial_traj);

                index_max_traj = index_max_traj(prom_max_traj > PROMINENCE_TRHESH);
                index_min_traj = index_min_traj(prom_min_traj > PROMINENCE_TRHESH);

                % locate current trial in eeg event
                cur_trial_idx = find([event_cur_task.trial_number] == t);

                %
                %             if length(trial_starts) ~= length(trial_ends)
                %                 warning(strcat(['Subject ', eeg_struct(s).subject, ...
                %                     ' does not have an equal number of start and end trial ' ...
                %                     'triggers in ', char(task_names{task}), '. Skipping.']))
                %                 break
                %             end

                % get the latencies of the current trial in the eeg data
                current_start_latency = event_cur_task(cur_trial_idx(1)).latency;
                current_end_latency = event_cur_task(cur_trial_idx(end)).latency;
                % add current start latency to the indicies of the peaks (which are in the same sampling rate
                % as the eeg signal due to upsampling)
                current_trial_peak_latencies = sort([index_max_traj; index_min_traj]);
                current_peak_latencies = current_start_latency + current_trial_peak_latencies;

                % for each of the current peak latencies...
                for idx = 1:length(current_peak_latencies)

                    % find the event that is one event before the peak
                    % (which is the largest negative latency)
                    tmp = [[event_cur_task.latency] - current_peak_latencies(idx)];
                    current_event_idx = max(find(tmp <= 0 ));

                    % insert the peak event markers at position in question
                    % (copy event before it and adjust its values)
                    event_cur_task = [event_cur_task(1:current_event_idx-1), ...
                        event_cur_task(current_event_idx), event_cur_task(current_event_idx:end)];

                    % To which conditions does the peak belong to?
                    if 
                    %     "occlusion":    20,
                    %     "reappear":     21,
                    %     "fourth_trial": 22,
                    %     "start_constant": 23,
                    %     "end_constant": 24,
                    % replace the copied rows' type with S 40, making sure the
                    % second event is overwritten
                    event_cur_task(current_event_idx+1).type = 'S 40';
                    event_cur_task(current_event_idx+1).code = 'inserted';
                    event_cur_task(current_event_idx+1).latency = current_peak_latencies(idx);
                    event_cur_task(current_event_idx+1).trial_latency = current_trial_peak_latencies(idx);
                    event_cur_task(current_event_idx+1).trial_latency_ms = event_cur_task(current_event_idx+1).trial_latency/250*1000;
                    event_cur_task(current_event_idx+1).trial_number = t;
                    event_cur_task(current_event_idx+1).occlusion = occ_state;
                    event_cur_task(current_event_idx+1).constant = const_state;

                    % in order to separate the peaks in the
%                     conditions, I need to add a field that labels each
%                     peak as either having happened while the trajectory
%                     was occluded or while it was visible. TODO.
% in the end this will be used in the STUDY to select a design and the
% independent variable under edit deisgn
% additional thought: It might also make sense to add the error for each
% epoch in the event structure as a continuous variable 

                end
            end
            % copy the event structure into a temporary field in eeg_struct
            eeg_struct(s).(task_names{task}) =  event_cur_task;
        end
        % concatenate the two fields so eeglab can work with them
        eeg_struct(s).track_event_peaks = [eeg_struct(s).(task_names{1}), eeg_struct(s).(task_names{2})];
    else
        warning(strcat(['Skipping subject ', eeg_struct(s).subject, ...
            ' due to unequal number of trial start and trial end triggers!', ...
            ' And therefore missing trial latencies. ']));
    end
end


%% Find Peaks of Pursuit Data and put them in Events

% TODO: change it to be two different peak markers, one for max, one for
% min
% "S 41": Peak max
% "S 51": Peak min

% prominence in pixel space at 20 for pursuit peaks 
% set time window after traj peak - if there is a direction change in the
% same direction, it counts
% change peak marker to peak marker that are either max or min - both for
% traj and for pursuit. 
% reject epochs for the erp analysis that do not contain pursuit peaks in
% the same direction 


%% Add latencies of trial a events to trial b events

for s = 1:length(subj_ids)
    event = eeg_struct(s).track_event_peaks;
    first_task_b_idx = min(find(strcmp({event.task}, 'task_b')))+1; % for
    % some weird reason, the first event of task b is not actually of task
    % b...
    for lat = first_task_b_idx:length(event)            
        event(lat).latency = event(lat).latency + event(first_task_b_idx-1).latency;
    end
    eeg_struct(s).track_event_peaks = event;
end


%% Remove historical fields; can be commented out here easily for re-tracing changes

% tmp_struct = eeg_struct;

for s = 1:size(eeg_struct, 2)
    eeg_struct(s).event = eeg_struct(s).track_event_peaks;
end
eeg_struct = rmfield(eeg_struct, ["track_event", "track_event_peaks"]);

% isequal(fieldnames(ALLEEG), fieldnames(tmp_struct))


%% Add Fields in Event Strucure for Occlusion and Constant/Random TODO

% copy_struct = eeg_struct;

for s = 1:length(subj_ids)

    %apply add_occl_events --> create OCCL var in EEG.event (coding
    %occl = occl/non_occl
    eeg_struct(s) = add_occl_events(eeg_struct(s));

        %apply add_traj_events --> create TRAJ var in EEG.event (coding
    %traj = rand1/const/rand2
    eeg_struct(s) = add_traj_events(eeg_struct(s));

end


%% Reject Trials Behaviorally


% store max and mean errors and exclude trials which start with error.  
count = 1;
count2 = 1;
for s = 1:length(subj_ids)
    for task = 1:2
        for t = 1:size(track_data(s).trials.(task_names{task}), 2)
            %             error_cell{s}{task}{t} = track_data(s).upsamp_data.(task_names{task})(t).error;
            cur_mean_errors = track_data(s).upsamp_data.(task_names{task})(t).mean_error;
            cur_error = track_data(s).upsamp_data.(task_names{task})(t).error;
            % store biggest error value in current trial
            cur_max_errors = max(cur_error);
            % store which data we are dealing with
            which_error = [s, task, t];
            % store in cell together with info which trial it is
            error_max_cell{count} = {cur_max_errors, which_error};
            error_cell{count} = {cur_mean_errors, which_error};
            % if trial starts with latrge error, it is assumed that
            % subjects moved joystick during break. 
            if cur_error(1) > 0.2;
                % store these values in cell. 
                joystick_moved_at_0{count2} = which_error;
                count2 = count2 + 1;
            end
            count = count + 1;
        end
    end
end

% check test script to know where these values come from. 

% % trials to exclude:
% % subject, task, trial
% [24, 2, 46];
% [16, 2, 70];
% [30, 2, 2];
% [19, 1, 22];
% [3, 2, 38];
% [2, 1, 53];
% [20, 2, 40];
% [20, 2, 10];
% [17, 1, 20];
% [17, 1, 19];
% [16, 2, 70];
% [18, 2, :];
% check subj 18 and 17
% as well as all trials where the joystick was moved more than 0.2 of the
% screen off the center.
% add visually rejected trials to rem_trials
rem_trials = [[24, 2, 46];[16, 2, 70];[30, 2, 2];[19, 1, 22];[3, 2, 38];[2, 1, 53];...
    [20, 2, 40];[20, 2, 10];[17, 1, 20];[17, 1, 19];[16, 2, 70]];
all_trials_18 = [1:72]';
% put all the different trials that are to be rejected together. 
all_trials_18 = [repmat([18, 2], size(all_trials_18,1), 1),all_trials_18];
rem_trials(end+1:end+size(all_trials_18,1), :) = all_trials_18;
tmp = cell2mat(joystick_moved_at_0');
rem_trials(end+1:end+size(tmp,1), :) = tmp;

clear cur_subj cur_task cur_trial

for s = unique(sort(rem_trials(:,1)))' % took me half an hour, but for loops loop through the columns... duh!
    for task = unique(sort(rem_trials(s == rem_trials(:,1), 2)))'
        for t = rem_trials(s == rem_trials(:,1) & task == rem_trials(:,2), 3)'

            % delete the eeg events
            cur_subj = eeg_struct(s).event;
            cur_task = cur_subj(strcmp({cur_subj.task}, task_names{task}));
            cur_trial = cur_task([cur_task.trial_number] == t);

            for d = 1:size({cur_trial.type},2)
                cur_trial(d).type = 'DEL';
                cur_trial(d).code = 'bad_trial';
            end

            cur_task([cur_task.trial_number] == t) = cur_trial;
            cur_subj(strcmp({cur_subj.task}, task_names{task})) = cur_task;
            %             for f = 1:length(field_names)
            %                 {eeg_struct(s).event.(field_names{f})} = {cur_subj.(field_names{f})};
            %             end
            eeg_struct(s).event = cur_subj;
            clear cur_subj cur_task cur_trial

            % delete the tracking trials
            cur_subj = track_data(s);
            cur_task = cur_subj.upsamp_data.(task_names{task});
            cur_trial = cur_task(t);
            field_names = fieldnames(cur_trial);
            for f = 1:length(field_names)
                cur_trial.(field_names{f}) = nan(length(cur_trial.(field_names{f})), 1);
            end
            cur_task(t) = cur_trial;
            cur_subj.upsamp_data.(task_names{task}) = cur_task;
            track_data(s) = cur_subj;

            clear cur_subj cur_task cur_trial

        end
    end
end


%% Replace Constant Traj Trigger from .vmrk with calculated from .npz TODO

%align constant trajectories of several trials
%compare constant trajectory and trial trajectory at every point
%calculate variance of difference
%should be minimal at constant trajectory

% s = 1;
% t = 2;
% % add constant traj path to matlab path
% tmp_path = strsplit(file_path, '\');
% tmp_path(end) = [];
% const_traj_path = [strjoin(tmp_path, '\'), '\functions'];
% addpath(const_traj_path);
% % load constant traj
% const_traj_fix = load([const_traj_path, 'const_traj_fixed.mat']);
% % upsample constant traj
% % x
% const_traj_fix_upsamp = linspace(const_traj_fix(1,1), const_traj_fix(end,1), round(length(const_traj_fix(:,1))/FR*SR))';
% % y
% const_traj_fix_upsamp(:,2) = spline(const_traj_fix(:,1), const_traj_fix(:,2), const_traj_fix_upsamp);
% % plot(const_traj_fix_upsamp(:,1), const_traj_fix_upsamp(:,2))
% 
% for s = 1:length(subj_ids)
%     for task = 1:2
%         for t = 1:size(track_data(s).trials.(task_names{task}), 2)
%             % load current trial of interest
%             cur_trial = track_data(s).upsamp_data.(task_names{task})(t);
%             cur_traj = [cur_trial.traj_x, cur_trial.traj_y];
%             % use align_const_traj function to get new event latencies
%             [shift, start_ind, end_ind] = align_to_const_traj(const_traj_fix_upsamp, cur_traj);
%         end
%     end
% end


%% Save sets

% https://eeglab.org/tutorials/ConceptsGuide/Data_Structures.html

out_path = strjoin([grandparent_path, "Emulation-Data-Output", "03_parallelize_with_traj"], filesep);
EEG_file_name_suffix = "EEG";
track_file_name_suffix = "all_tracking_data.mat";

for s = 1:size(track_data, 2)

    file_name = strjoin([eeg_struct(s).subject, EEG_file_name_suffix], '_' );
    pop_saveset(eeg_struct(s), 'filename', char(file_name), 'filepath', char(out_path));

end
file_name = strcat([out_path, track_file_name_suffix]);
save(strjoin(file_name), 'track_data');

